# -*- coding: utf-8 -*-
"""homework20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kC2D695gsHEyAkG0izXjnet5-PYDzhAx
"""

from google.colab import files
uploaded=files.upload()

import cv2
import numpy as np
import matplotlib.pyplot as plt


# -------------------------
# Utilities: Gaussian, conv
# -------------------------
def gaussian_kernel(size, sigma=1.0):
    assert size % 2 == 1 and size >= 1
    k = size // 2
    x, y = np.mgrid[-k:k+1, -k:k+1]
    g = np.exp(-(x**2 + y**2) / (2 * sigma**2))
    g = g / (2 * np.pi * sigma**2)
    return g / g.sum()


def convolve(image, kernel):

    img = image.astype(np.float64)
    kh, kw = kernel.shape
    ph, pw = kh // 2, kw // 2
    padded = np.pad(img, ((ph, ph), (pw, pw)), mode='edge')
    out = np.zeros_like(img, dtype=np.float64)
    for i in range(out.shape[0]):
        for j in range(out.shape[1]):
            out[i, j] = np.sum(padded[i:i+kh, j:j+kw] * kernel)
    return out


# -------------------------
# Sobel (gradients)
# -------------------------
def sobel_filters(img):
    Kx = np.array([[-1, 0, 1],
                   [-2, 0, 2],
                   [-1, 0, 1]], dtype=np.float64)
    Ky = np.array([[1, 2, 1],
                   [0, 0, 0],
                   [-1, -2, -1]], dtype=np.float64)

    Ix = convolve(img, Kx)
    Iy = convolve(img, Ky)

    magnitude = np.hypot(Ix, Iy)  # float64
    angle = np.arctan2(Iy, Ix)    # radians, [-pi, pi]
    return magnitude, angle


# -------------------------
# Non-Maximum Suppression
# -------------------------
def non_max_suppression(mag, angle):

    H, W = mag.shape
    Z = np.zeros((H, W), dtype=np.float64)
    # Convert angle to degrees in [0,180)
    ang = np.degrees(angle) % 180

    for i in range(1, H - 1):
        for j in range(1, W - 1):
            q = 255.0
            r = 255.0
            a = ang[i, j]

            # determine neighbors to compare
            if (0 <= a < 22.5) or (157.5 <= a < 180):
                q = mag[i, j + 1]
                r = mag[i, j - 1]
            elif (22.5 <= a < 67.5):
                q = mag[i + 1, j - 1]
                r = mag[i - 1, j + 1]
            elif (67.5 <= a < 112.5):
                q = mag[i + 1, j]
                r = mag[i - 1, j]
            elif (112.5 <= a < 157.5):
                q = mag[i - 1, j - 1]
                r = mag[i + 1, j + 1]

            if (mag[i, j] >= q) and (mag[i, j] >= r):
                Z[i, j] = mag[i, j]
            else:
                Z[i, j] = 0.0

    return Z


# -------------------------
# Double Threshold
# -------------------------
def double_threshold(img, low_ratio=0.05, high_ratio=0.15):
    high = img.max() * high_ratio
    low = img.max() * low_ratio  # corrected: low is based on max, not on high
    strong_val = 255
    weak_val = 75

    res = np.zeros(img.shape, dtype=np.uint8)
    strong_indices = img >= high
    weak_indices = (img >= low) & (img < high)

    res[strong_indices] = strong_val
    res[weak_indices] = weak_val
    return res, weak_val, strong_val


# -------------------------
# Hysteresis (edge tracking)
# -------------------------
def hysteresis(img, weak_val=75, strong_val=255):
    H, W = img.shape
    out = img.copy()
    # iterate until no changes (or do one pass: typical is iterative until stable)
    changed = True
    while changed:
        changed = False
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                if out[i, j] == weak_val:
                    # if any neighbor is strong -> promote
                    neighborhood = out[i - 1:i + 2, j - 1:j + 2]
                    if np.any(neighborhood == strong_val):
                        out[i, j] = strong_val
                        changed = True
                    else:
                        pass
    out[out != strong_val] = 0
    return out


# -------------------------
# Full pipeline (with options)
# -------------------------
def canny_from_scratch(img_gray_uint8, gauss_size=None, sigma=1.0,
                       low_ratio=0.05, high_ratio=0.15, return_intermediates=False):

    # 1. optionally smooth
    if gauss_size is not None:
        kernel = gaussian_kernel(gauss_size, sigma)
        smooth = convolve(img_gray_uint8.astype(np.float64), kernel)
    else:
        smooth = img_gray_uint8.astype(np.float64)

    # 2. gradients
    mag, ang = sobel_filters(smooth)

    # normalize magnitude to range 0..255 for stability in further steps (but keep float)
    if mag.max() > 0:
        mag = (mag / mag.max()) * 255.0

    # 3. NMS
    nms = non_max_suppression(mag, ang)

    # 4. double threshold
    thresh_img, weak_val, strong_val = double_threshold(nms, low_ratio, high_ratio)

    # 5. hysteresis
    final = hysteresis(thresh_img, weak_val, strong_val)

    if return_intermediates:
        steps = {
            'smoothed': np.clip(smooth, 0, 255).astype(np.uint8),
            'magnitude': np.clip(mag, 0, 255).astype(np.uint8),
            'nms': np.clip(nms, 0, 255).astype(np.uint8),
            'threshold_map': thresh_img
        }
        return final, steps
    else:
        return final


# -------------------------
# Experiment runner + plotting
# -------------------------
def run_experiments_and_plot(img_path, kernel_sizes=[None, 3, 5, 7],
                             sigma=1.0, low_ratio=0.05, high_ratio=0.15, save_results=False):
    """
    kernel_sizes: list containing integers (3,5,7) or None (to test no Gaussian)
    """
    # load
    img_bgr = cv2.imread(img_path)
    if img_bgr is None:
        raise FileNotFoundError(f"Can't read image: {img_path}")
    img_gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

    results = []
    for k in kernel_sizes:
        final, steps = canny_from_scratch(img_gray, gauss_size=k, sigma=sigma,
                                          low_ratio=low_ratio, high_ratio=high_ratio,
                                          return_intermediates=True)
        results.append((k, final, steps))

    # plotting
    n = len(results)
    plt.figure(figsize=(12, 4 * n))

    # Show original
    plt.subplot(n, 5, 1)
    plt.imshow(img_gray, cmap='gray')
    plt.title("Original")
    plt.axis('off')

    # For each experiment show smoothed, magnitude, nms, threshold_map, final
    for idx, (k, final, steps) in enumerate(results):
        row = idx + 1
        base = (idx) * 5
        title_k = "No Gaussian" if k is None else f"Gaussian k={k}"
        # Smoothed
        plt.subplot(n, 5, base + 2)
        plt.imshow(steps['smoothed'], cmap='gray')
        plt.title(f"{title_k}\nSmoothed")
        plt.axis('off')
        # Magnitude
        plt.subplot(n, 5, base + 3)
        plt.imshow(steps['magnitude'], cmap='gray')
        plt.title("Gradient Magnitude")
        plt.axis('off')
        # NMS
        plt.subplot(n, 5, base + 4)
        plt.imshow(steps['nms'], cmap='gray')
        plt.title("Non-max Suppression")
        plt.axis('off')
        # Threshold map
        plt.subplot(n, 5, base + 5)
        plt.imshow(steps['threshold_map'], cmap='gray')
        plt.title("Double Threshold (weak/strong)")
        plt.axis('off')
        # Final (separate column)
        plt.subplot(n, 5, base + 1)
        plt.imshow(final, cmap='gray')
        plt.title(f"Final Edges\n({title_k})")
        plt.axis('off')

        if save_results:
            kname = "no-gauss" if k is None else f"k{k}"
            cv2.imwrite(f"edges_{kname}.png", final)
            cv2.imwrite(f"smoothed_{kname}.png", steps['smoothed'])
            cv2.imwrite(f"mag_{kname}.png", steps['magnitude'])
            cv2.imwrite(f"nms_{kname}.png", steps['nms'])
            cv2.imwrite(f"thresh_{kname}.png", steps['threshold_map'])

    plt.tight_layout()
    plt.show()
    return results


# -------------------------
# If run as script: example
# -------------------------
if __name__ == "__main__":
    # === USER SETTINGS ===
    img_path = "sapla.jpg"         # <-- change to your image file
    kernels_to_test = [None, 3, 5, 7]   # None => no Gaussian smoothing
    sigma = 1.0
    low_ratio = 0.05
    high_ratio = 0.15
    save_out = False
    # =====================

    res = run_experiments_and_plot(img_path,
                                   kernel_sizes=kernels_to_test,
                                   sigma=sigma,
                                   low_ratio=low_ratio,
                                   high_ratio=high_ratio,
                                   save_results=save_out)

    # res is list of tuples (k, final_edge_map_uint8, steps_dict)
    # You can further analyze res programmatically if desired.